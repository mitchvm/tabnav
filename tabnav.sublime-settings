{
	"capture_level": "content",

	// When false, table markup lines are skipped when moving and not included in selections.
	// To temporarily include markup lines, use the "Include markup lines in selections" command.
	// Can also be overridden on a per-context basis.
	"include_markup": false,

	// When true, whitespace is trimmed from the selected regions' text prior to putting it 
	// on the clipboard with the "Copy selections" commands. The Sublime Text selections themselves
	// are not altered.
	"trim_on_copy": true,
	
	// To override individual context configs or add new contexts without
	// overriding everything, place overrides in a "user_contexts" element,
	// not "contexts".
	"contexts":
	{
		"markdown": 
		{
			"selector": "text.html.markdown",
			"except_selector": "markup.raw",
			// These patterns match both "bordered" and "borderless" Markdown tables.
			// See the README for override patterns if you only want to match on bordered tables.
			"patterns": [
				{
					// Markdown tables can have one markup row directly under the heading row.
					// It contains dashes, and optional colons to indicate text justification.
					"line": "^(?P<table>(\\|?\\s*[:-]+\\s*(?=\\|))+\\|\\s*[:-]*\\s*)$",
					"cell": [
						"(?P<cell>\\|?(?P<markup>\\s*[:-]+\\s*))(?=\\|)",
						"(?P<cell>\\|(?P<markup>\\s*[:-]+\\s*))$" // Captures the last cell of a borderless table.
					]
				},
				{
					"cell":[
						"(?P<cell>\\|?(?P<markup>(?P<content>\\s*?(?P<trimmed>\\B|(?:\\S.*?))\\s*)))(?=\\|)",
						"(?P<cell>\\|(?P<markup>(?P<content>\\s*?(?P<trimmed>(?:\\B(?=\\s))|(?:\\S.*?))\\s*)))$" // Captures the last cell of a borderless table.
					]
				}
			],
		},
		"orgmode":
		{
			"selector": "text.orgmode",
			"except_selector": "orgmode.raw.block",
			// Org Mode has three forms of table markup rows:
			// 1) Simple separator rows - e.g. for headings
			// 2) A column grouping row
			// 3) A column width row
			"patterns": [
				{
					"line": "^\\s*(?P<table>\\|-[-+]*\\|)\\s*$", // Separator rows start with "|-"
					"cell": [
						"^(?P<cell>\\|(?P<markup>-+))(?=\\+|\\|)",
						"(?P<cell>\\+(?P<markup>-+))(?=\\+|\\|)" // Inner cells are bordered with '+', not '|'
					]
				},
				{
					"line": "^\\s*(?P<table>\\|\\s*/\\s*\\|(?:\\s*<?\\s*>?\\s*\\|)*)\\s*$",
					"cell": [
						"^(?P<cell>\\|(?P<markup>\\s*/\\s*))(?=\\|)", // First cell contains "/"
						"(?P<cell>\\|(?P<markup>\\s*<?>?\\s*))(?=\\|)" // All other cells are empty, or contain "<" and/or ">""
					]
				},
				{
					"line": "^\\s*(?P<table>\\|(?:\\s*\\|)*(?:\\s*<\\d+>\\s*\\|)(?:\\s*(?:<\\d+>)?\\s*\\|)*)\\s*$", // At least one cell must have a "<1>" form width, and all other must be empty.
					"cell": "(?P<cell>\\|(?P<markup>\\s*(?:<\\d+>)?\\s*))(?=\\|)"
				},
				{
					"line": "^\\s*(?P<table>\\|.*\\|)\\s*$",
					"cell": "(?P<cell>\\|(?P<markup>(?P<content>\\s*?(?P<trimmed>\\B|(?:\\S.*?))\\s*)))(?=\\|)"
				}
			]
		},
		"auto_csv":
		{
			// This context is handled as a special case in the code. It doesn't automatically
			// map to a syntax (because there is no common CSV syntax), and it allows the column
			// delimiter to be formatted into the pattern regexes at runtime.
			// TabNav attempts to automatically determine the delimiter to use:
			// 1) If the current file syntax is from either of the Advanced CSV or Rainbow CSV packages,
			//    the delimiter set by those packages is used.
			//      - Note: Rainbow CSV "simple" syntaxes aren't truly supported. Cells that _start_
			//        with a double-quote (optionally preceded by spaces) will be treated as quoted cells.
			// 2) If the Set CSV Delimiter command has been run on the current view, the delimiter
			//    defined by that command is used.
			// 3) If the first line of the file contains only one of the "auto_delimiters", then it is
			//    assumed to be the delimiter:
			//    * Comma (,)
			//    * Semi-colon (;)
			//    * Pipe (|)
			//    * Tab
			// 4) If all else fails, use the "default_delimiter".
			"auto_delimiters": [",", ";", "\\|", "\\t"],
			"default_delimiter": ",",
			// Because CSV cells can be optionally quoted, and double-quotes themselves can also
			// be contained in the cell (escaped by double-double-quote), the matching gets a bit
			// tricky. If the cell starts with a quote (after optional whitespace), then it needs
			// to end with either a single quote, or three quotes, followed by optional whitespace.
			// _Each_ of these patterns match one of three scenarios within the <content> group:
			// 1) Empty or whitespace-only cell
			// 2) Unquoted content
			// 3) Quoted content
			"patterns": {
				"cell": [
					"^(?P<cell>(?P<markup>(?P<content> *?(?P<trimmed>\\B|(?:[^\" ].*?)|(?:\"(?:\"{{2}}|[^\"])*?\")) *)))(?={0})", // First cell of the line - no preceding delimiter
					"(?P<cell>{0}(?P<markup>(?P<content> *?(?P<trimmed>\\B|(?:[^\" ].*?)|(?:\"(?:\"{{2}}|[^\"])*?\")) *)))(?={0})", // Middle cells - delimiters on both ends
					"(?P<cell>{0}(?P<markup>(?P<content> *?(?P<trimmed>\\B|(?:[^\"].*?)|(?:\"(?:\"{{2}}|[^\"])*?\")) *)))$" // Last cell of the line - no final delimiter look-ahead
				]
			},
			"enable_explicitly": true, // We'll only infer the auto_csv context if tabnav has been explicitly enabled on a particular view
			"selector": null, // There is no global selector that matches all CSV syntaxes. This is a special case.
		}
	},

	"log_level": "WARNING"
}